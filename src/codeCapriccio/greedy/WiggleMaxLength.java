package codeCapriccio.greedy;

public class WiggleMaxLength {
    /*
    * 题意（leetcode376. 摆动序列）：
    *   如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列 。
    *   第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
    *   例如，[1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3)是正负交替出现的。
    *   相反，[1, 4, 7, 2, 5]和[1, 7, 4, 5, 5]不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
    *   子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
    *   给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
    * 解题思路：
    *   局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
    *   整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。
    *   每个拐点处就是一个符合条件的摆动点，所以找到峰值数就是摆动序列的长度。
    *   具体处理方法：
    *       1. 遍历下标0~length-1的点，计算每个元素的prediff（前差值）和curdiff（后差值）是否符合条件
    *       2. 首元素的prediff设为0，相当于延申一个与首元素相同的元素
    *       3. 尾元素不遍历，因为长度为1的nums默认摆动序列为1，故可把result初值设为1来处理
    *       4. 相同元素取最右边的判断是否是峰值
    */

    public int wiggleMaxLength(int[] nums) {
        // 长度为1则直接返回1
        if(nums.length == 1)
            return 1;
        int preDiff = 0;    // 首元素左边延申一个相等的值
        int curDiff = 0;
        int result = 1;
        for (int i = 0; i < nums.length - 1; i++) {
            curDiff = nums[i+1] - nums[i];
            if((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)){
                result++;
                preDiff = curDiff;
            }
        }
        return result;
    }
}
